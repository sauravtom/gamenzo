import { NextRequest } from 'next/server';
import { GoogleGenerativeAI } from '@google/generativeai';

// System prompt for game generation
const SYSTEM_PROMPT = `You're an extremely proficient creative coding agent, and can code effects, games, generative art.
Write javascript code assuming it's in a live p5js environment.
Return the code block.
You can include a short paragraph explaining your reasoning and the result in human readable form.
There can be no external dependencies: all functions must be in the returned code.
Make extra sure that all functions are either declared in the code or part of p5js.
The user can modify the code, go along with the user's changes.`;

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const { messages, code, message, systemInstructions, conversationHistory, currentCode } = body;
    
    // Support both new and legacy API formats
    const userMessage = message || '';
    const userConversation = conversationHistory || [];
    const userCode = currentCode || code || '';

    // Check for API key
    const apiKey = process.env.GEMINI_API_KEY;
    if (!apiKey) {
      return new Response(JSON.stringify({ error: 'Gemini API key not configured' }), {
        status: 500,
        headers: { 'Content-Type': 'application/json' },
      });
    }
  
    // Initialize the Gemini client
    const genAI = new GoogleGenerativeAI(apiKey);
    
    // Use Gemini Pro with thinking mode
    const model = genAI.getGenerativeModel({
      model: 'gemini-1.5-pro',
      generationConfig: {
        temperature: 0.9,
        topP: 0.95,
        topK: 40,
        maxOutputTokens: 8192,
      },
    });

    // Build conversation history
    const history: Array<{role: string; parts: Array<{text: string}>}> = [];
    
    // Add system instruction
    history.push({
      role: 'user',
      parts: [{ text: systemInstructions || SYSTEM_PROMPT }],
    });
    
    history.push({
      role: 'model',
      parts: [{ text: 'I understand. I\'m ready to help you create p5.js games, effects, and generative art. I\'ll provide complete, self-contained JavaScript code that runs in the p5.js environment.' }],
    });

    // Add context about current code if provided
    if (userCode && userCode !== '') {
      history.push({
        role: 'user',
        parts: [{ text: `Current code context:\n\`\`\`javascript\n${userCode}\n\`\`\`` }],
      });
      history.push({
        role: 'model',
        parts: [{ text: 'I can see the current code. I\'ll take this into account for any modifications or improvements.' }],
      });
    }
    
    // Add message history from existing conversation
    const messagesToProcess = userConversation.length ? userConversation : messages || [];
    for (const msg of messagesToProcess) {
      if (msg && (msg.role === 'user' || msg.role === 'assistant')) {
        history.push({
          role: msg.role === 'assistant' ? 'model' : 'user',
          parts: [{ text: msg.content || msg.explanation || '' }],
        });
      }
    }
    
    // Add the new user message if provided
    if (userMessage) {
      history.push({
        role: 'user',
        parts: [{ text: userMessage }],
      });
    }

    // Create a stream response
    const stream = new ReadableStream({
      async start(controller) {
        try {
          // Generate content with streaming
          const result = await model.generateContentStream({
            contents: history,
          });

          let isThinking = false;
          let thoughtBuffer = '';
          let contentBuffer = '';

          // Process the stream
          for await (const chunk of result.stream) {
            const chunkText = chunk.text();
            
            // Check if this is thinking content
            if (chunkText.includes('<thinking>')) {
              isThinking = true;
              thoughtBuffer = chunkText.substring(chunkText.indexOf('<thinking>') + 10);
              continue;
            }
            
            if (isThinking) {
              if (chunkText.includes('</thinking>')) {
                thoughtBuffer += chunkText.substring(0, chunkText.indexOf('</thinking>'));
                isThinking = false;
                
                // Send thinking data
                controller.enqueue(new TextEncoder().encode(
                  `data: ${JSON.stringify({ thinking: thoughtBuffer })}\n\n`
                ));
                
                // Process remaining content after </thinking>
                const remainingContent = chunkText.substring(chunkText.indexOf('</thinking>') + 11);
                if (remainingContent) {
                  contentBuffer += remainingContent;
                  controller.enqueue(new TextEncoder().encode(
                    `data: ${JSON.stringify({ text: remainingContent })}\n\n`
                  ));
                }
              } else {
                thoughtBuffer += chunkText;
              }
            } else {
              // Regular content
              contentBuffer += chunkText;
              controller.enqueue(new TextEncoder().encode(
                `data: ${JSON.stringify({ text: chunkText })}\n\n`
              ));
            }
          }
          // Send done signal
          controller.enqueue(new TextEncoder().encode('data: [DONE]\n\n'));
          controller.close();
        } catch (error) {
          console.error('Streaming error:', error);
          controller.enqueue(new TextEncoder().encode(
            `data: ${JSON.stringify({ error: 'Failed to generate response' })}\n\n`
          ));
          controller.close();
        }
      },
    });

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
      },
    });
  } catch (error) {
    console.error('Gemini API error:', error);
    return new Response(JSON.stringify({ error: 'Failed to process request' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    });
  }
}
